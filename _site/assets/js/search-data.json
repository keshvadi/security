{"0": {
    "doc": "About",
    "title": "Coputer Network Security",
    "content": "TO-DO . ",
    "url": "/about.html#coputer-network-security",
    
    "relUrl": "/about.html#coputer-network-security"
  },"1": {
    "doc": "About",
    "title": "Source Code Formatting",
    "content": "This repository has auto-formatting enabled. The preferred way to format source is through Prettier on your local machine. Install Node on your computer, run npm install -g yarn, and then run yarn. To format code, use the yarn prettier command, which will automatically format all .md and .html files. There is also a GitHub Action to format code which can be dispatched manually. Go to the Actions tab, find the Auto-Format Source action, and manually trigger a workflow dispatch against the target branch. A CI check is enabled which runs Prettier and fails if Prettier detects any formatting errors. run locally: . bundle exec jekyll serve . ",
    "url": "/about.html#source-code-formatting",
    
    "relUrl": "/about.html#source-code-formatting"
  },"2": {
    "doc": "About",
    "title": "License",
    "content": "This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. ",
    "url": "/about.html#license",
    
    "relUrl": "/about.html#license"
  },"3": {
    "doc": "About",
    "title": "About",
    "content": " ",
    "url": "/about.html",
    
    "relUrl": "/about.html"
  },"4": {
    "doc": "Glossary",
    "title": "Glossary",
    "content": "| Term | Definition | Chapter | . | security | Enforcing a desired property in the presence of an attacker | 1 | . | threat model | A thread model is a model of who your attacker is and what resources they have | 1 | . | kiss principle | Keep It Simple, Stupid | 1 | . | deterrence | Deterrence refers to stopping the attack before it happens | 1 | . | prevention | Prevention refers to stopping the attack as it happens | 1 | . | detection | Detection refers to learning that there was an attack after the attack has taken place | 1 | . | response | Response refers to doing something about the attack after the attack has taken place | 1 | . | securities is economics | Securities is economics is a security principle that says that defenses are not free and are often less than the sum of their parts | 1 | . | least privilege | Least Privilege is a security principle wherein one should consider what permissions an entity or program needs to be able to do its job correctly and only grant privileges that are needed for correct functioning and nothing more | 1 | . | separation of responsibility | Separation of responsibility is a security principle wherein if you need to have a privilege, consider requiring multiple parties to work together (collude) to exercise it | 1 | . | ensure complete mediation | Ensure complete mediation is a security principle wherein you ensure that every access point is monitored and protected | 1 | . | reference monitor | A reference monitor is a single point through which all access must occur, like a network firewall, for example | 1 | . | shannon’s maxim | Shannon’s Maxim is a security principle wherein the enemy knows the system, meaning that you should assume that the attacker knows every detail about the system you are working with | 1 | . | know your threat model | Knowing your threat model is a security principle wherein you should understand your attacker, their resources, and their motivation | 1 | . | consider human factors | Consider human factors is a security principle wherein if your system is unusable, it will be unused | 1 | . | defense in depth | Defense in depth is a security principle wherein you should layer multiple types of defenses | 1 | . | use fail-safe defaults | Use fail-safe defaults is a security principle that states you should construct systems that fail in a safe state, balancing security and usability | 1 | . | design in security from the start | Design in security from the start is a security principle wherein you should consider all security principles when designing a new system, rather than patching it afterwards | 1 | . ",
    "url": "/glossary.html",
    
    "relUrl": "/glossary.html"
  },"5": {
    "doc": "Network Security",
    "title": "Network Security",
    "content": "We’ve discussed web applications, however, what supports the actual Internet? Network security is our final module of the course, where we’re going to go through the procotols that explain how users communicate across a network. We’ll also cover the attacks that exist against these protocols, and methods to protect against them. ",
    "url": "/network/",
    
    "relUrl": "/network/"
  },"6": {
    "doc": "Web Security",
    "title": "Web Security",
    "content": "It would not be too much of a stretch to say that much of today’s world is built upon the Internet. Many of the services that run on top of the Internet come with their own class of vulnerabilities and defenses to match. In particular, we will be focusing on web security, which covers a class of attacks that target web pages and web services. ",
    "url": "/web/",
    
    "relUrl": "/web/"
  },"7": {
    "doc": "Cryptography",
    "title": "Cryptography",
    "content": "In this unit, we’ll be studying cryptography, techniques for securing information and communication in the presence of an attacker. In particular, we will see how we can prevent adversaries from reading or altering our private data. In a nutshell, cryptography is about communicating securely over insecure communication channels. The ideas we’ll examine have significant grounding in mathematics, and in general constitute the most systematic and formal set of approaches to security that we’ll cover. ",
    "url": "/crypto/",
    
    "relUrl": "/crypto/"
  },"8": {
    "doc": "Security Principles",
    "title": "Security Principles",
    "content": "In this section, we will look at some general principles for secure system design. These ideas also allow us to examine existing systems to understand their security properties. In other words, this section contains a list of “things to remember” when thinking about security. We teach these security principles because they appear frequently in all aspects of the security field. You may hear about them in academic literature and in later parts of this class. ",
    "url": "/principles/",
    
    "relUrl": "/principles/"
  },"9": {
    "doc": "Introduction",
    "title": "Computer Network Security",
    "content": "Welcome to the Computer Network Security webbook. If you are viewing this on GitHub, you can access the interactive, formatted version of this book at the link below: . https://keshvadi.github.io/security/ . ",
    "url": "/#computer-network-security",
    
    "relUrl": "/#computer-network-security"
  },"10": {
    "doc": "Introduction",
    "title": "About this Book",
    "content": "This webbook is currently a work in progress (Winter 2026). It is built from my course lecture notes and is scheduled to be completed by May 2026. ",
    "url": "/#about-this-book",
    
    "relUrl": "/#about-this-book"
  },"11": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"12": {
    "doc": "Introduction to Networking",
    "title": "Introduction to Networking",
    "content": "To discuss network security, first we need to know how the network is designed. This section provides a (simplified) overview of the various Internet layers and how they interact. ",
    "url": "/network/intro.html",
    
    "relUrl": "/network/intro.html"
  },"13": {
    "doc": "Introduction to Networking",
    "title": "1. Local Area Networks",
    "content": "The primary goal of the Internet is to move data from one location to another. A good analogy for the Internet is the postal system, which we’ll refer to throughout this section. The first building block we need is something that moves data across space, such as bits on a wire, radio waves, carrier pigeons, etc. Using our first building block, we can connect a group of local machines in a local area network (LAN). Note that in a LAN, all machines are connected to all other machines. This allows any machine on the LAN to send and receive messages from any other machine on the same LAN. You can think of a LAN as an apartment complex, a local group of nearby apartments that are all connected. However, it would be infeasible to connect every machine in the world to every other machine in the world, so we introduce a router to connect multiple LANs. A router is a machine that is connected to two or more LANs. If a machine wants to send a message to a machine on a different LAN, it sends the message to the router, which forwards the message to the second LAN. You can think of a router as a post office: to send a message somewhere outside of your local apartment complex, you’d take it to the post office, and they would forward your message to the other apartment complex. With enough routers and LANs, we can connect the entire world in a wide area network, which forms the basis of the Internet. ",
    "url": "/network/intro.html#1-local-area-networks",
    
    "relUrl": "/network/intro.html#1-local-area-networks"
  },"14": {
    "doc": "Introduction to Networking",
    "title": "2. Internet layering",
    "content": "You may have noticed that this design uses layers of abstraction to build the Internet. The lowest layer (layer 1, also called the physical layer) moves bits across space. Then, layer 2 (the link layer) uses layer 1 as a building block to connect local machines in a LAN. Finally, layer 3 (the internetwork layer) connects many layer 2 LANs. Each layer relies on services from a lower layer and provides services to a higher layer. Higher layers contain richer information, while lower layers provide the support necessary to send the richer information at the higher layers. This design provides a clean abstraction barrier for implementation. For example, a network can choose to use wired or wireless communication at Layer 1, and the Layer 1 implementation does not affect any protocols at the other layers. In total, there are 7 layers of the Internet, as defined by the OSI 7-layer model. However, this model is a little outdated, so some layers are obsolete, and additional layers for security have been added since then. We will see these higher layers later. | Layer | Name | . | 7 | Application | . | 6.5 | Secure Transport | . | 6 | obsolete | . | 5 | obsolete | . | 4 | Transport | . | 3 | (Inter)Network | . | 2 | Link | . | 1 | Physical | . ",
    "url": "/network/intro.html#2-internet-layering",
    
    "relUrl": "/network/intro.html#2-internet-layering"
  },"15": {
    "doc": "Introduction to Networking",
    "title": "3. Protocols and Headers",
    "content": "Each layer has its own set of protocols, a set of agreements on how to communicate. Each protocol specifies how communication is structured (e.g. message format), how machines should behave while communicating (e.g. what actions are needed to send and receive messages), and how errors should be handled (e.g. a message timing out). To support protocols, messages are sent with a header, which is placed at the beginning of the message and contains some metadata such as the sender and recipient’s identities, the length of the message, identification numbers, etc. You can think of headers as the envelope of a letter: it contains the information needed to deliver the letter, and appears before the actual letter. Because multiple protocols across different layers are needed to send a message, we need multiple headers on each packet. Each message begins as regular human-readable text (the highest layer). As the message is being prepared to get sent, it is passed down the protocol stack to lower layers (similar to how C programs are passed to lower layers to translate C code to RISC-V to machine-readable bits). Each layer adds its own header to the top of the message provided from the layer directly above. When the message reaches the lowest layer, it now has multiple headers, starting with the header for the lowest layer first. Once the message reaches its destination, the recipient must unpack the message and decode it back into human-readable text. Starting at the lowest layer, the message moves up the protocol stack to higher layers. Each layer removes its header and provides the remaining content to the layer directly above. When the message reaches the highest layer, all headers have been processed, and the recipient sees the regular human-readable text from before. ",
    "url": "/network/intro.html#3-protocols-and-headers",
    
    "relUrl": "/network/intro.html#3-protocols-and-headers"
  },"16": {
    "doc": "Introduction to Networking",
    "title": "4. Addressing: MAC, IP, Ports",
    "content": "Depending on the layer, a machine can be referred to by several different addresses. Layer 2 (link layer) uses 48-bit (6-byte) MAC addresses to uniquely identify each machine on the LAN. This is not to be confused with MACs (message authentication codes) from the crypto section. Usually it is clear from context which type of MAC we are referring to, although sometimes cryptographic MACs are called MICs (message integrity codes) when discussing networking. MAC addresses are usually written as 6 pairs of hex numbers, such as ca:fe:f0:0d:be:ef. There is also a special MAC address, the broadcast address of ff:ff:ff:ff:ff:ff, that says “send this message to everyone on the local network.\" You can think of MAC addresses as apartment numbers: they are used to uniquely identify people within one apartment complex, but are useless for uniquely identifying one person in the world. (Imagine sending a letter addressed to “Apartment 5.” This might work if you’re delivering letters within your own apartment complex, but how many Apartment 5s exist in the entire world?) . Layer 3 (IP layer) uses 32-bit (4-byte) IP addresses to uniquely identify each machine globally. IP addresses are usually written as 4 integers between 0 and 255, such as 128.32.131.10. Because the Internet has grown so quickly, the most recent version of the layer 3 protocol, IPv6, uses 128-bit IP addresses, which are written as 8 2-byte hex values separated by colons, such as cafe:f00d:d00d:1401:2414:1248:1281:8712. However, for this class, you only need to know about IPv4, which uses 32-bit IP addresses. Higher layers are designed to allow each machine to have multiple processes communicating across the network. For example, your computer only has one IP address, but it may have multiple browser tabs and applications open that all want to communicate over the network. To distinguish each process, higher layers assign each process on a machine a unique 16-bit port number. You can think of port numbers as room numbers: they are used to uniquely identify one person in a building. The source and destination addresses are contained in the header of a message. For example, the Layer 2 header contains MAC addresses, the Layer 3 header contains IP addresses, and higher layer headers will contain port numbers. ",
    "url": "/network/intro.html#4-addressing-mac-ip-ports",
    
    "relUrl": "/network/intro.html#4-addressing-mac-ip-ports"
  },"17": {
    "doc": "Introduction to Networking",
    "title": "5. Packets vs. Connections",
    "content": "Notice that in the postal system example, the post office has no idea if you and your pen pal are having a conversation through letters. The Internet is the same: at the physical, link, and internetwork layers, there is no concept of a connection. A router at the link layer only needs to consider each individual packet and send it to its destination (or, in the case of a long-distance message, forward it to another router somewhere closer to the destination). At the lower layers, we call individual messages packets. Packets are usually limited to a fixed length. In order to actually create a two-way connection, we rely on higher layers, which maintain a connection by breaking up longer messages into individual packets and sending them through the lower layer protocols. Higher-layer connections can also implement cryptographic protocols for additional security, as we’ll see in the TLS section. Note that so far, the Internet design has not guaranteed any correctness or security. Packets can be corrupted in transit or even fail to send entirely. The IP (Internet Protocol) at layer 3 only guarantees best-effort delivery, and does not handle any errors. Instead, we rely on higher layers for correctness and security. ",
    "url": "/network/intro.html#5-packets-vs-connections",
    
    "relUrl": "/network/intro.html#5-packets-vs-connections"
  },"18": {
    "doc": "Introduction to Networking",
    "title": "6. Network Adversaries",
    "content": "Network adversaries can be sorted into 3 general categories. They are, from weakest to strongest: . Off-path Adversaries: cannot read or modify any packets sent over the connection. On-path Adversaries: can read, but not modify packets. In-path Adversaries: can read, modify, and block packets. Also known as a man-in-the-middle. Note that all adversaries can send packets of their own, including faking or spoofing the packet headers to appear like the message is coming from somebody else. This is often as simple as setting the “source\" field on the packet header to somebody else’s address. ",
    "url": "/network/intro.html#6-network-adversaries",
    
    "relUrl": "/network/intro.html#6-network-adversaries"
  },"19": {
    "doc": "Introduction to the Web",
    "title": "Introduction to the Web",
    "content": " ",
    "url": "/web/intro.html",
    
    "relUrl": "/web/intro.html"
  },"20": {
    "doc": "Introduction to the Web",
    "title": "1. URLs",
    "content": "Every resource (webpage, image, PDF, etc.) on the web is identified by a URL (Uniform Resource Locator). URLs are designed to describe exactly where to find a piece of information on the Internet. A basic URL consists of three mandatory parts: . http://www.example.com/index.html . The first mandatory part is the protocol, also called scheme, located before in the URL. In the example above, the protocol is http. The protocol tells your browser how to retrieve the resource. In this class, the only two protocols you need to know are HTTP, which we will cover in the next section, and HTTPS, which is a secure version of HTTP using TLS (refer to the networking unit for more details). Other protocols include git+ssh://, which fetches a git archive over an encrypted tunnel using ssh, or ftp://, which uses the old FTP (File Transfer Protocol) to fetch data. The second mandatory part is the location, also called domain, located after but before the next forward slash in the URL. In the example above, the location is www.example.com. This tells your browser which web server to contact to retrieve the resource. Optionally, the location may contain an optional username, which is followed by an @ character if present. For example, evanbot@www.example.com is a location with a username evanbot. All locations must include a computer identifier. This is usually a domain name such as www.example.com. Sometimes the location will also include a port number, such as www.example.com:81, to distinguish between different applications running on the same web server. We will discuss ports a bit more when we talk about TCP during the networking section. The third mandatory part is the path, located after the first single forward slash in the URL. In the example above, the path is /index.html. The path tells your browser which resource on the web server to request. The web server uses the path to determine which page or resource should be returned to you. One way to think about paths is to imagine a filesystem on the web server you’re contacting. The web server can use the path as a filepath to locate a specific page or resource. The path must at least consist of /, which is known as the “root”1 of the filesystem for the remote web site. Optionally, there can be a ? character after the path. This indicates that you are supplying additional arguments in the URL for the web server to process. After the ? character, you can supply an optional set of parameters separated by &amp; characters. Each parameter is usually encoded as a key-value pair in the format key=value. Your browser sends all this information to the web server when fetching a URL. See the next section for more details on URL parameters. Finally, there can be an optional anchor after the arguments, which starts with a # character. The anchor text is not sent to the server, but is available to the web page as it runs in the browser. The anchor is often used to tell your browser to scroll to a certain part of the webpage when loading it. For example, try loading https://en.wikipedia.org/wiki/Dwinelle_Hall#Floor_plan and https://en.wikipedia.org/wiki/Dwinelle_Hall#Construction and note that your browser skips to the section of the article specified in the anchor. In summary, a URL with all elements present may look like this: . http://evanbot@www.example.org:3261/whoami?k1=v1&amp;k2=v2#anchor . where http is the protocol, evanbot is the username, www.example.org is the computer location (domain), 3261 is the port, /whoami is the path, k1=v1&amp;k2=v2 are the URL arguments, and anchor is the anchor. Further reading: What is a URL? . ",
    "url": "/web/intro.html#1-urls",
    
    "relUrl": "/web/intro.html#1-urls"
  },"21": {
    "doc": "Introduction to the Web",
    "title": "2. HTTP",
    "content": "The protocol that powers the World Wide Web is the Hypertext Transfer Protocol, abbreviated as HTTP. It is the language that clients use to communicate with servers in order to fetch resources and issue other requests. While we will not be able to provide you with a full overview of HTTP, this section is meant to get you familiar with several aspects of the protocol that are important to understanding web security. ",
    "url": "/web/intro.html#2-http",
    
    "relUrl": "/web/intro.html#2-http"
  },"22": {
    "doc": "Introduction to the Web",
    "title": "3. HTTP: The Request-Response Model",
    "content": "Fundamentally, HTTP follows a request-response model, where clients (such as browsers) must actively start a connection to the server and issue a request, which the server then responds to. This request can be something like “Send me a webpage” or “Change the password for my user account to foobar.” In the first example, the server might respond with the contents of the web page, and in the second example, the response might be something as simple as “Okay, I’ve changed your password.” The exact structure of these requests will be covered in further detail in the next couple sections. The original version of HTTP, HTTP 1.1, is a text-based protocol, where each HTTP request and response contains a header with some metadata about the request or response and a payload with the actual contents of the request or response. HTTP2, a more recent version of HTTP, is a binary-encoded protocol for efficiency, but the same concepts apply. For all requests, the server generates and sends a response. The response includes a series of headers and, in the payload, the body of the data requested. ",
    "url": "/web/intro.html#3-http-the-request-response-model",
    
    "relUrl": "/web/intro.html#3-http-the-request-response-model"
  },"23": {
    "doc": "Introduction to the Web",
    "title": "4. HTTP: Structure of a Request",
    "content": "Below is a very simple HTTP request. GET / HTTP/1.1 Host: squigler.com Dnt: 1 . The first line of the request contains the method of the request (GET), the path of the request (/), and the protocol version (HTTP/1.1). This is an example of a GET request. Each line after the first line is a request header. In this example, there are two headers, the DNT header and the Host header. There are many HTTP headers defined in the HTTP spec which are used to convey various pieces of information, but we will only be covering a couple of them through this chapter. Here is another HTTP request: . POST /login HTTP/1.1 Host: squigler.com Content-Length: 40 Content-Type: application/x-url-formencoded Dnt: 1 username=alice@foo.com&amp;password=12345678 . Here, we have a couple more headers and a different request type: the POST request. ",
    "url": "/web/intro.html#4-http-structure-of-a-request",
    
    "relUrl": "/web/intro.html#4-http-structure-of-a-request"
  },"24": {
    "doc": "Introduction to the Web",
    "title": "5. HTTP: GET vs. POST",
    "content": "While there are quite a few methods for requests, the two types that we will focus on for this course are GET requests and POST requests. GET requests are generally intended for “getting” information from the server. POST requests are intended for sending information to the server that somehow modifies its internal state, such as adding a comment in a forum or changing your password. In the original HTTP model, GET requests are not supposed to change any server state. However, modern web applications often change server state in response to GET requests in query parameters. Of note, only POST requests can contain a body in addition to request headers. Notice that the body of the second example request contains the username and password that the user alice is using to log in. While GET requests cannot have a body, it can still pass query parameters via the URL itself. Such a request might look something like this: . GET /posts?search=security&amp;sortby=popularity Host: squigler.com Dnt: 1 . In this case, there are two query parameters, search and sortby, which have values of security and popularity, respectively. ",
    "url": "/web/intro.html#5-http-get-vs-post",
    
    "relUrl": "/web/intro.html#5-http-get-vs-post"
  },"25": {
    "doc": "Introduction to the Web",
    "title": "6. Elements of a Webpage",
    "content": "The HTTP protocol is designed to return arbitrary files. The response header usually specifies a media type that tells the browser how to interpret the data in the response body. Although the web can be used to return files of any type, much of the web is built in three languages that provide functionality useful in web applications. A modern web page can be thought of as a distributed application: there is a component running on the web server and a component running in the web browser. First, the browser makes an HTTP request to a web server. The web server performs some server-side computation and generates and sends an HTTP response. Then, the browser performs some browser-side computation on the HTTP response and displays the result to the user. ",
    "url": "/web/intro.html#6-elements-of-a-webpage",
    
    "relUrl": "/web/intro.html#6-elements-of-a-webpage"
  },"26": {
    "doc": "Introduction to the Web",
    "title": "7. Elements of a Webpage: HTML",
    "content": "HTML (Hypertext Markup Language) lets us create structured documents with paragraphs, links, fillable forms, and embedded images, among other features. You are not expected to know HTML syntax for this course, but some basics are useful for some of the attacks we will cover. Here are some examples of what HTML can do: . | Create a link to Google: &lt;a href=\"http://google.com\"&gt;Click me&lt;/a&gt; . | Embed a picture in the webpage: &lt;img src=\"http://example.org/picture.png\"&gt; . | Include JavaScript in the webpage: &lt;script&gt;alert(1)&lt;/script&gt; . | Embed the example.org webpage in the webpage: &lt;iframe src=\"http://example.org\"&gt;&lt;/iframe&gt; . | . Frames pose a security risk, since the outer page is now including an inner page that may be from a different, possibly malicious source. To protect against this, modern browsers enforce frame isolation, which means the outer page cannot change the contents of the inner page, and the inner page cannot change the contents of the outer page. ",
    "url": "/web/intro.html#7-elements-of-a-webpage-html",
    
    "relUrl": "/web/intro.html#7-elements-of-a-webpage-html"
  },"27": {
    "doc": "Introduction to the Web",
    "title": "8. Elements of a Webpage: CSS",
    "content": "CSS (Cascading Style Sheets) lets us modify the appearance of an HTML page by using different fonts, colors, and spacing, among other features. You are not expected to know CSS syntax for this course, but you should know that CSS is as powerful as JavaScript when used maliciously. If an attacker can force a victim to load some malicious CSS, this is functionally equivalent to the attacker forcing the victim to load malicious JavaScript. ",
    "url": "/web/intro.html#8-elements-of-a-webpage-css",
    
    "relUrl": "/web/intro.html#8-elements-of-a-webpage-css"
  },"28": {
    "doc": "Introduction to the Web",
    "title": "9. Elements of a Webpage: JavaScript",
    "content": "JavaScript is a programming language that runs in your browser. It is a very powerful language–in general, you can assume JavaScript can arbitrarily modify any HTML or CSS on a webpage. Webpages can include JavaScript in their HTML to allow for dynamic features such as interactive buttons. Almost all modern webpages use JavaScript. When a browser receives an HTML document, it first converts the HTML into an internal form called the DOM (Document Object Model). The JavaScript is then applied on the DOM to modify how the page is displayed to the user. The browser then renders the DOM to display the result to the user. Because JavaScript is so powerful, modern web browsers run JavaScript in a sandbox so that any JavaScript code loaded from a webpage cannot access sensitive data on your computer or even data on other webpages. Most exploits targeting the web browser itself require JavaScript, either because the vulnerability lies in the browser’s JavaScript engine, or because JavaScript is used to shape the memory layout of the program for improving the success rate of an attack. Almost all web browsers implement JavaScript as a Just In Time compiler, dynamically converting JavaScript into machine code2. Many modern desktop applications (notably Slack’s desktop client) are actually written in the Electron framework, which is effectively a cut down web browser running JavaScript. | It is called the root because the filesystem can be treated as a tree and this is where the tree starts. &#8617; . | Trivia: Running JavaScript fast is considered so important that ARM recently introduced a dedicated instruction, FJCVTZS (Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero), specifically to handle how JavaScript’s math operates. &#8617; . | . ",
    "url": "/web/intro.html#9-elements-of-a-webpage-javascript",
    
    "relUrl": "/web/intro.html#9-elements-of-a-webpage-javascript"
  },"29": {
    "doc": "Introduction to Cryptography",
    "title": "Introduction to Cryptography",
    "content": " ",
    "url": "/crypto/intro.html",
    
    "relUrl": "/crypto/intro.html"
  },"30": {
    "doc": "Introduction to Cryptography",
    "title": "1. Disclaimer: Don’t roll your crypto! ",
    "content": "In this book, we will learn the basic building blocks of cryptography, and in particular, just enough to get a feeling for how they work at a conceptual level. Understanding cryptography at a conceptual level will give you good intuition for how industrial systems use cryptography in practice. However, cryptography in practice is very tricky to get right. Actual real-world cryptographic implementations require great attention to detail and have hundreds of possible pitfalls. For example, private information might leak out through various side-channels, random number generators might go wrong, and cryptographic primitives might lose all security if you use them the wrong way. explaining all of those details and pitfalls is out of the scope of this book. that said, you should never implement your own cryptography using the algorithms you learn in this book as there is an importatnt lesson in security community: never roll your crypto. Instead, the cryptography we show you in this book is as much about educating you as a consumer as educating you as an engineer. If you find yourself needing an encrypted connection between two computers, or if you need to send an encrypted message to another person, you should use existing well-vetted cryptographic tools. However, you will often be faced with the problem of understanding how something is supposed to work. You might also be asked to evaluate the difference between alternatives. For that, you will need to understand the underlying cryptographic engineering involved. Similarly, there are sometimes applications that take advantage of cryptographic primitives in non-cryptographic ways, so it is useful to know the primitives. You never know when you might need a hash, an HMAC, or a block cipher for a non-security task that takes advantage of their randomness properties. In summary, know that we’re going to teach you just enough cryptography to be dangerous, but not enough to implement industrial-strength cryptography in practice. ",
    "url": "/crypto/intro.html#1-disclaimer-dont-roll-your-crypto-",
    
    "relUrl": "/crypto/intro.html#1-disclaimer-dont-roll-your-crypto-"
  },"31": {
    "doc": "Introduction to Cryptography",
    "title": "2. Brief History of Cryptography",
    "content": "The word “cryptography” comes from the Latin roots crypt, meaning secret, and graphia, meaning writing. So cryptography is quite literally the study of how to write secret messages. Schemes for sending secret messages go back to antiquity. 2,000 years ago, Julius Caesar employed what’s today referred to as the “Caesar cypher,” which consists of permuting the alphabet by shifting each letter forward by a fixed amount. For example, if Caesar used a shift by \\(3\\) then the message “cryptography” would be encoded as “fubswrjudskb”. With the development of the telegraph (electronic communication) during the 1800s, the need for encryption in military and diplomatic communications became particularly important. The codes used during this “pen and ink” period were relatively simple since messages had to be decoded by hand. The codes were also not very secure, by modern standards. The second phase of cryptography, the “mechanical era,” was the result of a German project to create a mechanical device for encrypting messages in an unbreakable code. The resulting Enigma machine was a remarkable feat of engineering. Even more remarkable was the massive British effort during World War II to break the code. The British success in breaking the Enigma code helped influence the course of the war, shortening it by about a year, according to most experts. There were three important factors in the breaking of the Enigma code. First, the British managed to obtain a replica of a working Enigma machine from Poland, which had cracked a simpler version of the code. Second, the Allies drew upon a great deal of brainpower, first with the Poles, who employed a large contingent of mathematicians to crack the structure, and then from the British, whose project included Alan Turing, one of the founding fathers of computer science. The third factor was the sheer scale of the code-breaking effort. The Germans figured that the Enigma was well-nigh uncrackable, but what they didn’t figure on was the unprecedented level of commitment the British poured into breaking it, once codebreakers made enough initial progress to show the potential for success. At its peak, the British codebreaking organization employed over 10,000 people, a level of effort that vastly exceeded anything the Germans had anticipated. They also developed electromechanical systems that could, in parallel, search an incredible number of possible keys until the right one was found. Modern cryptography is distinguished by its reliance on mathematics and electronic computers. It has its early roots in the work of Claude Shannon following World War II. The analysis of the one-time pad (discussed in the next chapter) is due to Shannon. The early 1970s saw the introduction of a standardized cryptosystem, DES, by the National Institute for Standards in Technology (NIST). DES answered the growing need for digital encryption standards in banking and other businesses. The decade starting in the late 1970s then saw an explosion of work on a computational theory of cryptography. ",
    "url": "/crypto/intro.html#2-brief-history-of-cryptography",
    
    "relUrl": "/crypto/intro.html#2-brief-history-of-cryptography"
  },"32": {
    "doc": "Introduction to Cryptography",
    "title": "3. Definitions",
    "content": "Intuitively, we can see that the Caesar cypher is not secure (try all 26 possible shifts and you’ll get the original message back), but how can we prove that it is, in fact, insecure? To formally study cryptography, we will have to define a mathematically rigorous framework that lets us analyze the security of various cryptographic schemes. The rest of this section defines some important terms that will appear throughout the unit. ",
    "url": "/crypto/intro.html#3-definitions",
    
    "relUrl": "/crypto/intro.html#3-definitions"
  },"33": {
    "doc": "Introduction to Cryptography",
    "title": "4. Definitions: Alice, Bob, Eve, and Mallory",
    "content": "The most basic problem in cryptography is one of ensuring the security of communications across an insecure medium. Two recurring members of the cast of characters in cryptography are Alice and Bob, who wish to communicate securely as though they were in the same room or were provided with a dedicated, untappable line. However, they only have available a telephone line or an Internet connection subject to tapping by an eavesdropping adversary, Eve. In some settings, Eve may be replaced by an active adversary Mallory, who can tamper with communications in addition to eavesdropping on them. The goal is to design a scheme for scrambling the messages between Alice and Bob in such a way that Eve has no clue about the contents of their exchange, and Mallory is unable to tamper with the contents of their exchange without being detected. In other words, we wish to simulate the ideal communication channel using only the available insecure channel. ",
    "url": "/crypto/intro.html#4-definitions-alice-bob-eve-and-mallory",
    
    "relUrl": "/crypto/intro.html#4-definitions-alice-bob-eve-and-mallory"
  },"34": {
    "doc": "Introduction to Cryptography",
    "title": "Definitions: Keys",
    "content": "The most basic building block of any cryptographic system (or cryptosystem) is the key. The key is a secret value that helps us secure messages. Many cryptographic algorithms and functions require a key as input to lock or unlock some secret value. There are two main key models in modern cryptography. In the symmetric key model, Alice and Bob both know the value of a secret key, and must secure their communications using this shared secret value. In the asymmetric key model, each person has a secret key and a corresponding public key. ",
    "url": "/crypto/intro.html#definitions-keys",
    
    "relUrl": "/crypto/intro.html#definitions-keys"
  },"35": {
    "doc": "Introduction to Cryptography",
    "title": "6. Definitions: Confidentiality, Integrity, Authenticity",
    "content": "As we mentioned, CIA traid is the goals of computer secuirty. In cryptography, there are still the three main security properties that we want to achieve. Confidentiality is the property that prevents adversaries from reading our private data. If a message is confidential, then an attacker does not know its contents. You can think about confidentiality like locking and unlocking a message in a lockbox. Alice uses a key to lock the message in a box and then sends the message (in the locked box) over the insecure channel to Bob. Eve can see the locked box, but cannot access the message inside since she does not have a key to open the box. When Bob receives the box, he is able to unlock it using the key and retrieve the message. Most cryptographic algorithms that guarantee confidentiality work as follows: Alice uses a key to encrypt a message by changing it into a scrambled form that the attacker cannot read. She then sends this encrypted message over the insecure channel to Bob. When Bob receives the encrypted message, he uses the key to decrypt the message by changing it back into its original form. We call the message plaintext when it is unencrypted and ciphertext when it is encrypted. Even if the attacker can see the encrypted ciphertext, they should not be able to decrypt it back into the corresponding plaintext–only the intended recipient, Bob, should be able to decrypt the message. Integrity is the property that prevents adversaries from tampering with our private data. If a message has integrity, then an attacker cannot change its contents without being detected. Authenticity is the property that lets us determine who created a given message. If a message has authenticity, then we can be sure that the message was written by the person who claims to have written it. You might be thinking that authenticity and integrity seem very closely related, and you would be correct; it makes sense that before you can prove that a message came from a particular person, you first have to prove that the message was not changed. In other words, before you can prove authenticity, you first have to be able to prove integrity. However, these are not identical properties and we will take a look at some edge cases as we delve further into the cryptographic unit. You can think about cryptographic algorithms that ensure integrity and authenticity as adding a seal on the message that is being sent. Alice uses the key to add a special seal, like a piece of tape on the envelope, on the message. She then sends the sealed message over the unsecure channel. If Mallory tampers with the message, she will break the tape on the envelope, and therefore break the seal. Without the key, Mallory cannot create her own seal. When Bob receives the message, he checks that the seal is untampered before unsealing the envelope and revealing the message. Most cryptographic algorithms that guarantee integrity and authenticity work as follows: Alice generates a tag or a signature on a message. She sends the message with the tag to Bob. When Bob receives the message and the tag, he verifies that the tag is valid for the message that was sent. If the attacker modifies the message, the tag should no longer be valid, and Bob’s verification will fail. This will let Bob detect if the message has been altered and is no longer the original message from Alice. The attacker should not be able to generate valid tags for their malicious messages. A related property that we may want our cryptosystem to have is deniability. If Alice and Bob communicate securely, Alice might want to publish a message from Bob and show it to a judge, claiming that it came from Bob. If the cryptosystem has deniability, there is no cryptographic proof available to guarantee that Alice’s published message came from Bob. For example, consider a case where Alice and Bob use the same key to generate a signature on a message, and Alice publishes a message with a valid signature. Then the judge cannot be sure that the message came from Bob–the signature could have plausibly been created by Alice. ",
    "url": "/crypto/intro.html#6-definitions-confidentiality-integrity-authenticity",
    
    "relUrl": "/crypto/intro.html#6-definitions-confidentiality-integrity-authenticity"
  },"36": {
    "doc": "Introduction to Cryptography",
    "title": "7: Overview of schemes",
    "content": "We will look at cryptographic primitives that provide confidentiality, integrity, and authentication in both the symmetric-key and asymmetric-key settings. |   | Symmetric-key | Asymmetric-key | . | Confidentiality | Block ciphers with chaining modes (e.g., AES-CBC) | Public-key encryption(e.g., El Gamal, RSA encryption) | . | Integrity and authentication | MACs (e.g., AES-CBC-MAC) | Digital signatures (e.g., RSA signatures) | . In symmetric-key encryption, Alice uses her secret key to encrypt a message, and Bob uses the same secret key to decrypt the message. In public-key encryption, Bob generates a matching public key and private key, and shares the public key with Alice (but does not share his private key with anyone). Alice can encrypt her message under Bob’s public key, and then Bob will be able to decrypt using his private key. If these schemes are secure, then no one except Alice and Bob should be able to learn anything about the message Alice is sending. In the symmetric-key setting, message authentication codes (MACs) provide integrity and authenticity. Alice uses the shared secret key to generate a MAC on her message, and Bob uses the same secret key to verify the MAC. If the MAC is valid, then Bob can be confident that no attacker modified the message, and the message actually came from Alice. In the asymmetric-key setting, public-key signatures (also known as digital signatures) provide integrity and authenticity. Alice generates a matching public key and private key, and shares the public key with Bob (but does not share her private key with anyone). Alice computes a digital signature of her message using her private key, and appends the signature to her message. When Bob receives the message and its signature, he will be able to use Alice’s public key to verify that no one has tampered with or modified the message, and that the message actually came from Alice. We will also look at several other cryptographic primitives. These primitives don’t guarantee confidentiality, integrity, or authenticity by themselves, but they have desirable properties that will help us build secure cryptosystems. These primitives also have some useful applications unrelated to cryptography. | Cryptographic hashes provide a one way digest: They enable someone to condense a long message into a short sequence of what appear to be random bits. Cryptographic hashes are irreversible, so you can’t go from the resulting hash back to the original message but you can quickly verify that a message has a given hash. | Many cryptographic systems and problems need a lot of random bits. To generate these we use a pseudo random number generator, a process which takes a small amount of true randomness and stretches it into a long sequence that should be indistinguishable from actual random data. | Key exchange schemes (e.g. Diffie-Hellman key exchange) allow Alice and Bob to use an insecure communication channel to agree on a shared random secret key that is subsequently used for symmetric-key encryption. | . ",
    "url": "/crypto/intro.html#7-overview-of-schemes",
    
    "relUrl": "/crypto/intro.html#7-overview-of-schemes"
  },"37": {
    "doc": "Introduction to Cryptography",
    "title": "8. Definitions: Kerckhoff’s Principle",
    "content": "Let’s now examine the threat model, which in this setting involves answering the question: How powerful are the attackers Eve and Mallory? . To consider this question, recall Kerckhoff’s principle from the earlier notes about security principles: . Cryptosystems should remain secure even when the attacker knows all internal details of the system. The key should be the only thing that must be kept secret, and the system should be designed to make it easy to change keys that are leaked (or suspected to be leaked). If your secrets are leaked, it is usually a lot easier to change the key than to replace every instance of the running software. (This principle is closely related to Shannon’s Maxim: Don’t rely on security through obscurity.) . Consistent with Kerckhoff’s principle, we will assume that the attacker knows the encryption and decryption algorithms.1 The only information the attacker is missing is the secret key(s). ",
    "url": "/crypto/intro.html#8-definitions-kerckhoffs-principle",
    
    "relUrl": "/crypto/intro.html#8-definitions-kerckhoffs-principle"
  },"38": {
    "doc": "Introduction to Cryptography",
    "title": "9. Definitions: Threat models",
    "content": "When analyzing the confidentiality of an encryption scheme, there are several possibilities about how much access an eavesdropping attacker Eve has to the insecure channel: . | Eve has managed to intercept a single encrypted message and wishes to recover the plaintext (the original message). This is known as a ciphertext-only attack. | Eve has intercepted an encrypted message and also already has some partial information about the plaintext, which helps with deducing the nature of the encryption. This case is a known plaintext attack. In this case Eve’s knowledge of the plaintext is partial, but often we instead consider complete knowledge of one instance of plaintext. | Eve can capture an encrypted message from Alice to Bob and re-send the encrypted message to Bob again. This is known as a replay attack. For example, Eve captures the encryption of the message “Hey Bob’s Automatic Payment System: pay Eve $$100$” and sends it repeatedly to Bob so Eve gets paid multiple times. Eve might not know the decryption of the message, but she can still send the encryption repeatedly to carry out the attack. | Eve can trick Alice to encrypt arbitrary messages of Eve’s choice, for which Eve can then observe the resulting ciphertexts. (This might happen if Eve has access to the encryption system, or can generate external events that will lead Alice to sending predictable messages in response.) At some other point in time, Alice encrypts a message that is unknown to Eve; Eve intercepts the encryption of Alice’s message and aims to recover the message given what Eve has observed about previous encryptions. This case is known as a chosen-plaintext attack. | . Eve can trick Bob into decrypting some ciphertexts. Eve would like to use this to learn the decryption of some other ciphertext (different from the ciphertexts Eve tricked Bob into decrypting). This case is known as a chosen-ciphertext attack. | A combination of the previous two cases: Eve can trick Alice into encrypting some messages of Eve’s choosing, and can trick Bob into decrypting some ciphertexts of Eve’s choosing. Eve would like to learn the decryption of some other ciphertext that was sent by Alice. (To avoid making this case trivial, Eve is not allowed to trick Bob into decrypting the ciphertext sent by Alice.) This case is known as a chosen-plaintext/ciphertext attack, and is the most serious threat model. | . Today, we usually insist that our encryption algorithms provide security against chosen-plaintext/ciphertext attacks, both because those attacks are practical in some settings, and because it is in fact feasible to provide good security even against this very powerful attack model. | The story of the Enigma gives one possible justification for this assumption: given how widely the Enigma was used, it was inevitable that sooner or later the Allies would get their hands on an Enigma machine, and indeed they did. &#8617; . | . ",
    "url": "/crypto/intro.html#9-definitions-threat-models",
    
    "relUrl": "/crypto/intro.html#9-definitions-threat-models"
  },"39": {
    "doc": "1. Security Principles",
    "title": "1. Security Principles",
    "content": " ",
    "url": "/principles/principles.html",
    
    "relUrl": "/principles/principles.html"
  },"40": {
    "doc": "1. Security Principles",
    "title": "1.1. Know your threat model",
    "content": "A threat model is a model of who your attacker is and what resources they have. Attackers target systems for various reasons, be it money, politics, fun, etc. Some aren’t looking for anything logical—some attackers just want to watch the world burn. Take, for example, your own personal security. Understanding your threat model has to do with understanding who and why might someone attack you; criminals, for example, could attack you for money, teenagers could attack you for laughs (or to win a dare), governments might spy on you to collect intelligence (but you probably are not important enough for that just yet), or intimate partners could spy on you. Once you understand who your attacker is and what resources they might possess, there are some common assumptions that we take into account for attackers: . | The attacker can interact with your systems without anyone noticing, meaning that you might not always be able to detect the attacker tampering with your system before they attack. | The attacker has some general information about your system, namely the operating system, any potential software vulnerabilities, etc. | The attacker is persistent and lucky; for example, if an attack is successful 1/1,000,000 times, the attacker will try 1,000,000 times. | The attacker is willing to devote time and resources to the attack (though this may vary; see “Security is Economics” below). | The attacker can coordinate several complex attacks across various systems. The attacker is not limited to to attacking only a single device, but can attack your entire network at the same time or chain multiple attacks together. | Every system is a potential target. For example, a casino was once hacked because a fish-tank thermometer was hacked within the network. | . Finally, be extremely vigilant when dealing with old code as the assumptions that were originally made might no longer be valid and the threat model might have changed. When the Internet was first created, for example, it was mostly populated by academics who (mostly) trusted one another. As such, several networking protocols made the assumption that all other network participants could be trusted and were not malicious. Today however, the Internet is populated by billions of devices, some of whom are malicious. As a result, many network protocols that were designed a long time ago are now suffering under the strain of attack. ",
    "url": "/principles/principles.html#11-know-your-threat-model",
    
    "relUrl": "/principles/principles.html#11-know-your-threat-model"
  },"41": {
    "doc": "1. Security Principles",
    "title": "1.2. Consider Human Factors",
    "content": "The key idea here is that security systems must be usable by ordinary people, and therefore must be designed to take into account the role that humans will play. For example, programmers are human and make mistakes. Similarly, users like convenience; if a security system is unusable and not user-friendly, no matter how secure it is, it will go unused. Users will find a way to subvert security systems if it makes their lives easier. No matter how secure your system is, it all comes down to people. Social engineering attacks, for example, exploit other people’s trust and access for personal gain. The takeaway here is to consider the tools that are presented to users, and try to make them fool-proof and as user-friendly as possible. For example, suppose your computer pops up with a notification that tells you it needs to restart to “finish installing important updates” while you are in the middle of working on something. If you are like the majority of the user population, you might click “remind me later”, pushing off the update. If the computer is attempting to fix a security patch, the longer the update gets delayed, the longer your computer is vulnerable to an attack. If updates inconvenience the user, they might forego the extra security for convenience. Another example: the NSA’s cryptographic equipment stores its key material on a small physical token. This token is built in the shape of an ordinary door key. To activate an encryption device, you insert the key into a slot on the device and turn the key. This interface is intuitively understandable, even for 18-year-old soldiers out in the field with minimal training in cryptography. ",
    "url": "/principles/principles.html#12-consider-human-factors",
    
    "relUrl": "/principles/principles.html#12-consider-human-factors"
  },"42": {
    "doc": "1. Security Principles",
    "title": "1.3. Security is economics",
    "content": "No system is completely, 100% secure against all attacks; rather, systems only need to be protected against a certain level of attacks. Since more security usually costs more money to implement, the expected benefit of your defense should be proportional to the expected cost of the attack. Essentially, there is no point putting a $100 lock on a $1 item. To understand this concept, we can think about physical safes, which come with a rating of their level of security. For instance, a consumer grade safe rated TL-15 is designed to resist attacks for up to 15 minutes by anyone with common tools; it might cost around $3,000. A TL-30, a safe that would resist attacks for up to 30 minutes with common tools, might cost around $5000. Finally, a TXTL-60 (a super high-end safe), which is rated to resist attacks for up to 60 minutes with common tools, a cutting torch, and up to 4 oz of explosives, might cost upwards of $50,000. Security usually comes at a cost. A more secure safe is going to cost you more than a less secure safe. With infinite money, you could use the best safe available to lock all your valuables, but since you don’t have infinite money, you must determine how valuable the thing you want to protect is, and you must judge how much you are willing to pay to protect it. This illustrates that security is often a cost-benefit analysis where someone needs to make a decision regarding how much security is worth. A corollary of this principle is you should focus your energy on securing the weakest links. Security is like a chain: a system is only as secure as the weakest link. Attackers follow the path of least resistance, and they will attack the system at its weakest point. There is no sense putting an expensive high-end deadbolt on a screen door; attackers aren’t going to bother trying to pick the lock when they can just rip out the screen and step through. A closely related principle is conservative design, which states that systems should be evaluated according to the worst security failure that is at all plausible, under assumptions favorable to the attacker. If there is any plausible circumstance under which the system can be rendered insecure, then it is prudent to consider seeking a more secure system. Clearly, however, we must balance this against “security is economics”: that is, we must decide the degree to which our threat model indicates we indeed should spend resources addressing the given scenario. ",
    "url": "/principles/principles.html#13-security-is-economics",
    
    "relUrl": "/principles/principles.html#13-security-is-economics"
  },"43": {
    "doc": "1. Security Principles",
    "title": "1.4. Detect if you can’t prevent",
    "content": "Prevention is stopping an attack from taking place, detection is simply learning that the attack has taken place, and response is doing something about the attack. The idea is that if you cannot prevent the attack from happening, you should at least be able to know that the attack has happened. Once you know that the attack has happened, you should find a way to respond, since detection without response is pointless. For example, Federal Information Processing Standard (FIPS) 140 provides technical standards for hardware components used by government contractors for encryption. Level III devices—the highest level of security in the standard—are intended to be tamper-resistant. However, Level III devices are very expensive. Level II devices are only required to be tamper-evident, so that if someone tampers with them, this will be visible (e.g., a seal will be visibly broken). This means they can be built more cheaply and used in a broader array of applications. When dealing with response, you should always assume that bad things will happen, and therefore prepare your systems for the worst case outcome. You should always plan security in a way that lets you get back to some form of a working state. For example, keeping offsite backups of computer systems is a great idea. Even if your system is completely destroyed, it should be survivable since all your data is backed up in some other location. ",
    "url": "/principles/principles.html#14-detect-if-you-cant-prevent",
    
    "relUrl": "/principles/principles.html#14-detect-if-you-cant-prevent"
  },"44": {
    "doc": "1. Security Principles",
    "title": "1.5. Defense in depth",
    "content": "The key idea of defense in depth is that multiple types of defenses should be layered together so an attacker would have to breach all the defenses to successfully attack a system. Take, for example, a castle defending its king. The castle has high walls. Behind those walls might be a moat, and then another layer of walls. Layering multiple simple defensive strategies together can make security stronger. However, defense in depth is not foolproof—no amount of walls will stop siege cannons from attacking the castle. Also, beware of diminishing returns—if you’ve already built 100 walls, the 101st wall may not add enough additional protection to justify the cost of building it (security is economics). Another example of defense in depth is through a composition of detectors. Say you had two detectors, \\(D_1\\) and \\(D_2\\), each of which have some rate of generating false alarms (alerts that are not actually a security compromise) and some rate of missed attacks (security compromises that didn’t trigger any alert). One way to use the two detectors would be to have them in parallel, meaning that either detector going off would trigger a response. This would increase the false alarm rate and decrease the rate of missed attacks. Or, we could also have the detectors in series, meaning that both detectors have to alert in order to trigger a response. In this case, the false alarm rate would decrease while the rate of missed attacks would increase. ",
    "url": "/principles/principles.html#15-defense-in-depth",
    
    "relUrl": "/principles/principles.html#15-defense-in-depth"
  },"45": {
    "doc": "1. Security Principles",
    "title": "1.6. Least privilege",
    "content": "Consider a research building that is home to a team of scientists as well as other people hired to maintain the building (janitors, IT staff, kitchen staff, etc.) Some rooms with sensitive research data might be only accessible to trusted scientists. These rooms should not be accessible to the others (e.g., kitchen staff). For best security practices, any one party should only have as much privilege as it needs to play its intended role. In technical terms, give a program the set of access privileges that it legitimately needs to do its job—but nothing more. Try to minimize how much privilege you give each program and system component. Least privilege is an enormously powerful approach. It doesn’t reduce the probability of failure, but it can reduce the expected cost of failures. The less privilege that a program has, the less harm it can do if it goes awry or becomes subverted. For instance, the principle of least privilege can help reduce the damage caused by buffer overflow. (We’ll discuss buffer overflows more in the next chapter.) If a program is compromised by a buffer overflow attack, then it will probably be completely taken over by an intruder, and the intruder will gain all the privileges the program had. Thus, the fewer privileges that a program has, the less harm is done if it should someday be penetrated by a buffer overflow attack. How does Unix do, in terms of least privilege? Answer: Pretty lousy. Every program gets all the privileges of the user that invokes it. For instance, if I run a editor to edit a single file, the editor receives all the privileges of my user account, including the powers to read, modify, or delete all my files. That’s much more than is needed; strictly speaking, the editor probably only needs access to the one file being edited to get the job done. How is Windows, in terms of least privilege? Answer: Just as lousy. Mobile phones do much better. Each app is sandboxed, and typically cannot access other apps’ data. If one app is malicious or compromised, the damage it can do is therefore limited. ",
    "url": "/principles/principles.html#16-least-privilege",
    
    "relUrl": "/principles/principles.html#16-least-privilege"
  },"46": {
    "doc": "1. Security Principles",
    "title": "1.7. Separation of responsibility",
    "content": "Split up privilege, so no one person or program has complete power. Require more than one party to approve before access is granted. In a nuclear missile silo, for example, two launch officers must agree before the missile can be launched. Another example of this principle in action is in a movie theater. To watch a movie, you first pay the cashier and get a ticket stub. Then, when you enter the movie theater, a different employee tears your ticket in half and collects one half of it, putting it into a lockbox. Why bother giving you a ticket that 10 feet later is going to be collected from you? One answer is that this helps prevent insider fraud. Employees might be tempted to let their friends watch a movie without paying. The presence of two employees makes an attack harder, since both employees must work together to let someone watch a movie without paying. In summary, if you need to protect a highly sensitive action, require multiple parties to work together to take that action, since it is more likely for a single party to be malicious than for all of the parties to be malicious and collude with one another. ",
    "url": "/principles/principles.html#17-separation-of-responsibility",
    
    "relUrl": "/principles/principles.html#17-separation-of-responsibility"
  },"47": {
    "doc": "1. Security Principles",
    "title": "1.8. Ensure complete mediation",
    "content": "When enforcing access control policies, make sure that you check every access to every object. This kind of thinking is helpful to detect where vulnerabilities could be. As such, you have to ensure that all access is monitored and protected. One way to accomplish this is through a reference monitor, which is a single point through which all access must occur. A security checkpoint at an airport is a good example of a reference monitor. All passengers are funneled through one or a small number of checkpoints, where they be scanned. If we make sure that these checkpoints are handled correctly and there is no way to bypass the checkpoint, this will be enough to protect hundreds of gates at the terminals. ",
    "url": "/principles/principles.html#18-ensure-complete-mediation",
    
    "relUrl": "/principles/principles.html#18-ensure-complete-mediation"
  },"48": {
    "doc": "1. Security Principles",
    "title": "1.9. Shannon’s Maxim",
    "content": "Shannon’s Maxim states that the attacker knows the system that they are attacking. “Security through obscurity” refers to systems that rely on the secrecy of their design, algorithms, or source code to be secure. The issue with this, however, is that it is extremely brittle and it is often difficult to keep the design of a system secret from a sufficiently motivated attacker. Historically, security through obscurity has a lousy track record: many systems that have relied upon the secrecy of their code or design for security have failed miserably. Someone relying on security through obscurity might reason like this: “this system is so obscure, only 100 people around the world understand anything about it, so what are the odds that an adversary will bother attacking it?” One problem with such reasoning is that such an approach is self-defeating in the long run. If the system becomes more popular, there will be more incentive to attack it, and then we cannot rely on its obscurity to keep attackers away. This doesn’t mean that open-source applications are necessarily more secure than closed-source applications. But it does mean that you shouldn’t trust any system that relies on security through obscurity, and you should probably be skeptical about claims that keeping the source code secret makes the system significantly more secure. As such, you should never rely on obscurity as part of your security. Always assume that the attacker knows every detail about the system that you are working with (including its algorithms, hardware, defenses, etc.) . A closely related principle is Kerckhoff’s Principle, which states that cryptographic systems should remain secure even when the attacker knows all internal details of the system. (We’ll discuss cryptographic systems more in the cryptography section.) The secret key should be the only thing that must be kept secret, and the system should be designed to make it easy to change keys that are leaked (or suspected to be leaked). If your secrets are leaked, it is usually a lot easier to change the key than to replace every instance of the running software. ",
    "url": "/principles/principles.html#19-shannons-maxim",
    
    "relUrl": "/principles/principles.html#19-shannons-maxim"
  },"49": {
    "doc": "1. Security Principles",
    "title": "1.10. Use fail-safe defaults",
    "content": "Choose default settings that “fail safe”, balancing security with usability when a system goes down. Ensure that if the security mechanisms fail or crash, they will default to secure behavior, not to insecure behavior. For example, when we get to firewalls, you will learn about default-deny policies, which start by denying all access, then allowing only those which have been explicitly permitted. Firewalls must explicitly decide to forward a given packet or else the packet is lost (dropped). If a firewall suffers a failure, no packets will be forwarded. Thus, a firewall fails safe. This is good for security. It would be more dangerous if it had fail-open behavior, since then all an attacker would need to do is wait for the firewall to crash (or induce a crash) and then the fort is wide open. ",
    "url": "/principles/principles.html#110-use-fail-safe-defaults",
    
    "relUrl": "/principles/principles.html#110-use-fail-safe-defaults"
  },"50": {
    "doc": "1. Security Principles",
    "title": "1.11. Design security in from the start",
    "content": "Trying to retrofit security to an existing application after it has already been spec’ed, designed, and implemented is usually difficult. At that point, you’re stuck with whatever architecture has been chosen, and you don’t have the option of decomposing the system in a way that ensures least privilege, separation of privilege, complete mediation, defense in depth, and other good properties. Backwards compatibility is often particularly painful, because you can be stuck with supporting the worst insecurities of all previous versions of the software. ",
    "url": "/principles/principles.html#111-design-security-in-from-the-start",
    
    "relUrl": "/principles/principles.html#111-design-security-in-from-the-start"
  },"51": {
    "doc": "1. Security Principles",
    "title": "1.12. The Trusted Computing Base (TCB)",
    "content": "Now that you understand some of the important principles for building secure systems, we will try to see what you can do at design time to implement these principles and improve security. The question we want to answer is how can you choose an architecture that will help reduce the likelihood of flaws in your system, or increase the likelihood that you will be able to survive such flaws? We begin with a powerful concept, the notion of a trusted computing base, also known as the TCB. In any system, the trusted computing base (TCB) is that portion of the system that must operate correctly in order for the security goals of the system to be assured. We have to rely on every component in the TCB to work correctly. However, anything that is outside the TCB isn’t relied upon in any way; even if it misbehaves or operates maliciously, it cannot defeat the system’s security goals. Generally, the TCB is made to be as small as possible since a smaller, simpler TCB is easier to write and audit. Suppose the security goal is that only authorized users are allowed to log into my Linux server using SSH. What is the TCB? Well, the TCB includes the SSH daemon, since it is the one that makes the authentication and authorization decisions; if it has a bug, or if it was programmed to behave maliciously, then it will be able to violate my security goal by allowing access to unauthorized users. The TCB also includes the operating system, since the operating system has the power to tamper with the operation of the SSH daemon (e.g., by modifying its address space). Likewise, the CPU is in the TCB, since we are relying upon the CPU to execute the SSH daemon’s machine instructions correctly. Suppose a web browser application is installed on the same machine; is the web browser in the TCB? Hopefully not! If we’ve built the system in a way that is at all reasonable, the SSH daemon is supposed to be protected (by the operating system’s memory protection) from interference by unprivileged applications, like a web browser. TCB Design Principles: Several principles guide us when designing a TCB: . | Unbypassable (or completeness): There must be no way to breach system security by bypassing the TCB. | Tamper-resistant (or security): The TCB should be protected from tampering by anyone else. For instance, other parts of the system outside the TCB should not be able to modify the TCB’s code or state. The integrity of the TCB must be maintained. | Verifiable (or correctness): It should be possible to verify the correctness of the TCB. This usually means that the TCB should be as simple as possible, as generally it is beyond the state of the art to verify the correctness of subsystems with any appreciable degree of complexity. | . Keeping the TCB simple and small is excellent. The less code you have to write, the fewer chances you have to make a mistake or introduce some kind of implementation flaw. Industry standard error rates are 1–5 defects per thousand lines of code. Thus, a TCB containing 1,000 lines of code might have 1–5 defects, while a TCB containing 100,000 lines of code might have 100–500 defects. If we need to then try to make sure we find and eliminate any defects that an adversary can exploit, it’s pretty clear which one to pick![^1] The lesson is to shed code: design your system so that as much code as possible can be moved outside the TCB. Benefits of TCBs: The notion of a TCB is a very powerful and pragmatic one as it allows a primitive yet effective form of modularity. It lets us separate the system into two parts: the part that is security-critical (the TCB), and everything else. This separation is a big win for security. Security is hard. It is hard to build systems that are secure and correct. The more stuff the system contains, the harder it is to assure its security. If we are able to identify a clear TCB, then we will know that only the parts in the TCB must be correct for the system to be secure. Thus, when thinking about security, we can focus our effort where it really matters. And, if the TCB is only a small fraction of the system, we have much better odds at ending up with a secure system: the less of the system we have to rely upon, the less likely that it will disappoint. In summary, some good principles are: . | Know what is in the TCB. Design your system so that the TCB is clearly identifiable. | Try to make the TCB unbypassable, tamper-resistant, and as verifiable as possible. | Keep It Simple, Stupid (KISS). The simpler the TCB, the greater the chances you can get it right. | Decompose for security. Choose a system decomposition/modularization based not just on functionality or performance grounds—choose an architecture that makes the TCB as simple and clear as possible. | . ",
    "url": "/principles/principles.html#112-the-trusted-computing-base-tcb",
    
    "relUrl": "/principles/principles.html#112-the-trusted-computing-base-tcb"
  },"52": {
    "doc": "1. Security Principles",
    "title": "1.13. TOCTTOU Vulnerabilities",
    "content": "A common failure of ensuring complete mediation involves race conditions. The time of check to time of use (TOCTTOU) vulnerability usually arises when enforcing access control policies such as when using a reference monitor. Consider the following code, which might run in a bank ATM: . procedure withdraw(amount w) { // contact central server to get balance 1. let b := balance 2. if b &lt; w, abort // contact central server to set the balance 3. set balance := b - w 4. give w dollars to the user } . This code takes as input the amount you want to withdraw, w. It then looks up your bank balance in the database. If you do not have enough money in your account to withdraw the specified amount, it aborts the transaction. If you do have enough money, it decrements your balance by the amount that you want to withdraw and then dispenses the cash to you. Suppose that multiple calls to withdraw can take place concurrently (i.e. two separate ATMs). Also suppose that the attacker can somehow pause the execution of procedure on one ATM. So suppose that your current account balance is $100 and you want to withdraw $100. At the first ATM, suppose you pause it after step 2. Then, you go over to the second ATM and proceed to withdraw $100 successfully (meaning that your account balance should now be $0). You then go back to the first ATM and unpause the procedure; since the account balance check was completed before you withdrew the money from the second ATM, the first ATM still thinks you have $100 in your account, and it allows you to withdraw another $100! So despite your bank account having only $100 to begin with, you ended up with $200. This is known as a Time-Of-Check To Time-Of-Use (TOCTTOU) vulnerability, because between the check and the use of whatever state was checked, the state somehow changed. In the above example, between the time that the balance was checked and the time that balance was set, the balance was somehow changed. ",
    "url": "/principles/principles.html#113-tocttou-vulnerabilities",
    
    "relUrl": "/principles/principles.html#113-tocttou-vulnerabilities"
  }
}
